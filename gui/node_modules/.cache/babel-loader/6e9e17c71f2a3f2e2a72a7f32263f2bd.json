{"ast":null,"code":"/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n'use strict';\n\nconst util = require('util');\n\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n\n  while (value[++index] === '0');\n\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n\n  if (toNumber === false) {\n    return String(input);\n  }\n\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n\n  while (input.length < maxLength) input = '0' + input;\n\n  return negative ? '-' + input : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = function () {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...arguments));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n\n  return [];\n};\n\nconst fillNumbers = function (start, end) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  } // fix negative zero\n\n\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = {\n    negatives: [],\n    positives: []\n  };\n\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  return range;\n};\n\nconst fillLetters = function (start, end) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n\n  return range;\n};\n\nconst fill = function (start, end, step) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, {\n      transform: step\n    });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options\n  };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;","map":{"version":3,"sources":["C:/Users/nikro/Documents/GitHub/ampersand/gui/node_modules/fill-range/index.js"],"names":["util","require","toRegexRange","isObject","val","Array","isArray","transform","toNumber","value","Number","String","isValidValue","isNumber","num","isInteger","zeros","input","index","slice","stringify","start","end","options","pad","maxLength","dash","padStart","toMaxLen","negative","length","toSequence","parts","negatives","sort","a","b","positives","prefix","capture","result","join","wrap","toRange","isNumbers","fromCharCode","stop","toRegex","rangeError","RangeError","inspect","invalidRange","strictRanges","invalidStep","step","TypeError","fillNumbers","descending","startString","endString","stepString","Math","max","abs","padded","maxLen","format","push","range","fillLetters","charCodeAt","min","fill","opts","module","exports"],"mappings":"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","sourcesContent":["/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n"]},"metadata":{},"sourceType":"script"}